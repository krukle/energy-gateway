%----------------------------------------------------------------------------------------
% Method
%----------------------------------------------------------------------------------------
\section{Method}\label{sec:method}

\subsection{Hardware}

The Energy Gateway system consists of the following hardware components:

\begin{itemize}
  \item ESP32 devkit board
  \item Heltec Wireless Stick
  \item Breadboard
  \item Connecting wires
\end{itemize}

The ESP32 devkit board is a low-cost microcontroller board that is based on the ESP32 microcontroller. It was chosen due to its low cost, integrated Wi-Fi and Bluetooth capabilities~\cite{platformio:esp32-devkitv1}.

Any device could have been used to simulate a serial device, but the Heltec Wireless Stick was chosen due to availability and ease of use.

\subsection{WiFi Provisioning through Bluetooth}

Internet of Things has brought about a need for efficient communication protocols for various devices, including the ESP32 microcontroller. The WiFi provisioning through Bluetooth is a novel method that enables streamlined configuration of the WiFi credentials of an ESP32 module through the use of a Bluetooth Low Energy (BLE)-enabled device, such as a smartphone.

The WiFi provisioning through Bluetooth consists of the following steps:

\begin{enumerate}
  \item The ESP32 module starts a BLE server with a predefined service UUID and advertises itself as a WiFi provisioning device.
  \item A BLE-enabled device scans for nearby BLE devices and connects to the ESP32 module using its service UUID, enabling communication between the devices.
  \item The BLE-enabled device sends a protobuf message to the ESP32 module using the \texttt{wifi\_scan endpoint}, requesting a list of available WiFi networks.
  \item The ESP32 module scans for nearby WiFi networks and sends back a protobuf message with the list of SSIDs and RSSIs to the BLE-enabled device using the \texttt{wifi\_scan} endpoint.
  \item The BLE-enabled device selects a WiFi network from the list and sends its SSID and password to the ESP32 module using the \texttt{wifi\_config} endpoint.
  \item The ESP32 module validates the credentials and attempts to connect to the selected WiFi network, sending back a protobuf message with the connection status (success or failure) to the BLE-enabled device using the \texttt{wifi\_config} endpoint. If the connection is successful, the ESP32 module obtains an Internet Protocol (IP) address from the WiFi network and stops advertising itself as a WiFi provisioning device. It also stops accepting any further provisioning requests from other devices. In the event of a connection failure, the ESP32 module resets its internal state machine and clears its provisioned credentials. It continues advertising itself as a WiFi provisioning device until it receives valid credentials or until it is manually stopped by calling the \texttt{wifi\_prov\_mgr\_stop\_provisioning()} function~\cite{espressif:esp-idf-programming-guide}.
\end{enumerate}

The WiFi provisioning through Bluetooth requires an application on both sides: one on the ESP32 module and one on the BLE-enabled device. Espressif provides an Android app that serves as a client~\cite{google-play:esp-ble-provisioning}.

Overall, the WiFi provisioning through Bluetooth method provides a solution for efficent WiFi configuration on ESP32 modules. This approach mitigates the need for hard-coded credentials or user input, simplifying the process for users to connect their devices to a WiFi network. Through the use of BLE-enabled devices, this method offers efficient and secure communication between devices, making it a potential solution in the realm of IoT.

\subsection{OTA Updates}

The OTA update system was developed to allow for remote firmware updates of the ESP32 board via a Wi-Fi connection. To implement this functionality, the partition table of the device was configured with at least two "OTA app slot" partitions and an "OTA Data Partition". An esp-idf component, \texttt{energy\_gateway\_ota}, was created to handle the initialization, download, verification, and activation of new firmware images from a given URL. This component was integrated into the \texttt{main.c} file to periodically check for updates and perform them if available. The firmware image was hosted on a web server configured to serve the firmware image over HTTPS (refer to Figure \ref{fig:web_server}). The \texttt{energy\_gateway\_ota} component downloaded and verified the integrity of the firmware image and activated it by setting the boot partition to the OTA app slot that was not previously selected for booting. The system also enables the possibility for rollback to a previous firmware image in the event of a failed update.

\subsection{UART communication}

The Energy Gateway's final product requires the capability to poll from and send data to serial devices. To fulfill this requirement, we utilized the UART (Universal Asynchronous Receiver/Transmitter) protocol, which enables asynchronous communication between two devices in a full-duplex manner. The UART protocol is widely utilized in embedded systems, like the ESP32, to interface with sensors and actuators.

To simulate the UART protocol, we established a Heltec Wireless Stick as a serial device and connected it to the ESP32 module via UART (refer to Figure \ref{fig:uart_connection}). We programmed the ESP32 module to request data from the Heltec Wireless Stick at a rate of 20Hz, while the Heltec Wireless Stick was programmed to transmit a random number between 0 and 255 to the ESP32 module every 50ms. The ESP32 module then evaluated whether the received data was too high or low. If the data was deemed too low, a 0 was dispatched to the Heltec Wireless Stick, and if it was too high, a 1 was transmitted. Our solution passed our testing and in the final Energy Gateway product, the ESP32 module will acquire data from the serial device only at a rate of 2Hz.

\subsection{Concurrency}

When it comes to developing software with the Espressif IoT Development Framework (ESP-IDF), understanding the intricacies of priority levels is paramount for effective task management~\cite{Davis:2016}. The underlying operating system for ESP-IDF is FreeRTOS, which is a real-time operating system designed for microcontrollers that provides a multitasking environment for running multiple tasks simultaneously on a single processor. The priority-based preemptive scheduling algorithm employed by FreeRTOS is an essential feature that allows for efficient task management~\cite{espressif:esp-idf-programming-guide}.

ESP-IDF utilizes a range of 26 priority levels, numbered from 0 (highest) to 25 (lowest). The variable \texttt{ESP\_TASK\_PRIO\_MAX}, which represents the maximum allowed priority level in ESP-IDF, is currently set to 25 and can be found in the FreeRTOSConfig.h file\cite{espressif:freertosconfig}. This limitation ensures that the system remains stable and responsive, even when multiple high-priority tasks are running concurrently. By utilizing these priority levels effectively, developers can optimize system performance and ensure that critical tasks receive the necessary resources to execute efficiently~\cite{espressif:esp-idf-programming-guide}.

Choosing the appropriate priority level for a task requires careful consideration of its criticality and potential impact on the system. For instance, a high-priority task that reads data from a serial port demands immediate attention to avoid data loss or errors. In our project, we assigned a priority level of \texttt{ESP\_TASK\_PRIO\_MAX - 6} (level 19) to our serial-reading task. This priority level strikes a balance between prioritizing our task and allowing other tasks to run when needed. It also provides some headroom above the default priority levels of many other tasks in the system~\cite{espressif:esp-idf-programming-guide}, ensuring that our task receives immediate attention while still allowing for efficient resource allocation.

Moreover, it is worth noting that prioritization is not a one-size-fits-all solution. Different tasks have different criticality levels, and thus require different priority levels. Some tasks may be less critical but more time-consuming, while others may require frequent access to system resources. As such, the priority level should be carefully selected to ensure efficient task management and optimize system performance.

In conclusion, understanding the intricacies of priority levels is essential when programming with esp-idf. By choosing the appropriate priority level for each task, we can ensure efficient task management, avoid system performance degradation, and optimize system performance. With only 25 priority levels in ESP-IDF, developers have limited flexibility to assign priority levels based on the specific needs of their projects.
