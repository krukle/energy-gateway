%----------------------------------------------------------------------------------------
% Method
%----------------------------------------------------------------------------------------
\section{Method}\label{sec:method}

\subsection{Hardware}

The Energy Gateway system consists of the following hardware components:

\begin{itemize}
  \item ESP32 devkit board
  \item Heltec Wireless Stick
  \item Breadboard
  \item Connecting wires
\end{itemize}

The ESP32 devkit board is a low-cost microcontroller board that is based on the ESP32 microcontroller. It was chosen due to its low cost, integrated Wi-Fi and Bluetooth capabilities~\cite{platformio:esp32-devkitv1}.

Any device could have been used to simulate a serial device, but the Heltec Wireless Stick was chosen due to availability and ease of use.

\subsection{WiFi Provisioning through Bluetooth}

The WiFi provisioning through Bluetooth process involves the ESP32 module starting a BLE server with a predefined service UUID and advertising itself as a WiFi provisioning device. A BLE-enabled device connects to the ESP32 module using its service UUID, and communication between the devices is established. The BLE-enabled device requests a list of available WiFi networks using the \texttt{wifi\_scan} endpoint, and the ESP32 module responds with a list of SSIDs and RSSIs using the same endpoint. The BLE-enabled device selects a WiFi network and sends its SSID and password to the ESP32 module using the \texttt{wifi\_config} endpoint. The ESP32 module validates the credentials, attempts to connect to the selected WiFi network, and sends a connection status message to the BLE-enabled device using the same endpoint \cite{espressif:esp-idf-programming-guide}.

The WiFi provisioning through Bluetooth method requires applications on both the ESP32 module and the BLE-enabled device, and the Google Play store offers the Espressif Android app that serves as a client \cite{google-play:esp-ble-provisioning}.

\subsection{OTA Updates}

The OTA update system was developed to allow for remote firmware updates of the ESP32 board via a Wi-Fi connection. To implement this functionality, the partition table of the device was configured with at least two "OTA app slot" partitions and an "OTA Data Partition". An esp-idf component, \texttt{energy\_gateway\_ota}, was created to handle the initialization, download, verification, and activation of new firmware images from a given URL. This component was integrated into the \texttt{main.c} file to periodically check for updates and perform them if available. The firmware image was hosted on a web server configured to serve the firmware image over HTTPS (refer to Figure \ref{fig:web_server}). The \texttt{energy\_gateway\_ota} component downloaded and verified the integrity of the firmware image and activated it by setting the boot partition to the OTA app slot that was not previously selected for booting. The system also enables the possibility for rollback to a previous firmware image in the event of a failed update.

\subsection{UART communication}

The Energy Gateway's final product requires the capability to poll from and send data to serial devices. To fulfill this requirement, we utilized the UART (Universal Asynchronous Receiver/Transmitter) protocol, which enables asynchronous communication between two devices in a full-duplex manner. The UART protocol is widely utilized in embedded systems, like the ESP32, to interface with sensors and actuators.

To simulate the UART protocol, we established a Heltec Wireless Stick as a serial device and connected it to the ESP32 module via UART (refer to Figure \ref{fig:uart_connection}). We programmed the ESP32 module to request data from the Heltec Wireless Stick at a rate of 20Hz, while the Heltec Wireless Stick was programmed to transmit a random number between 0 and 255 to the ESP32 module every 50ms. The ESP32 module then evaluated whether the received data was too high or low. If the data was deemed too low, a 0 was dispatched to the Heltec Wireless Stick, and if it was too high, a 1 was transmitted. Our solution passed our testing and in the final Energy Gateway product, the ESP32 module will acquire data from the serial device only at a rate of 2Hz.

\subsection{Concurrency}

When it comes to developing software with the Espressif IoT Development Framework (ESP-IDF), understanding the intricacies of priority levels is paramount for effective task management~\cite{Davis:2016}. The underlying operating system for ESP-IDF is FreeRTOS, which is a real-time operating system designed for microcontrollers that provides a multitasking environment for running multiple tasks simultaneously on a single processor. The priority-based preemptive scheduling algorithm employed by FreeRTOS is an essential feature that allows for efficient task management~\cite{espressif:esp-idf-programming-guide}.

ESP-IDF utilizes a range of 26 priority levels, numbered from 0 (highest) to 25 (lowest). The variable \texttt{ESP\_TASK\_PRIO\_MAX}, which represents the maximum allowed priority level in ESP-IDF, is currently set to 25 and can be found in the FreeRTOSConfig.h file\cite{espressif:freertosconfig}. This limitation ensures that the system remains stable and responsive, even when multiple high-priority tasks are running concurrently. By utilizing these priority levels effectively, developers can optimize system performance and ensure that critical tasks receive the necessary resources to execute efficiently~\cite{espressif:esp-idf-programming-guide}.

Choosing the appropriate priority level for a task requires careful consideration of its criticality and potential impact on the system. For instance, a high-priority task that reads data from a serial port demands immediate attention to avoid data loss or errors. In our project, we assigned a priority level of \texttt{ESP\_TASK\_PRIO\_MAX - 6} (level 19) to our serial-reading task. This priority level strikes a balance between prioritizing our task and allowing other tasks to run when needed. It also provides some headroom above the default priority levels of many other tasks in the system~\cite{espressif:esp-idf-programming-guide}, ensuring that our task receives immediate attention while still allowing for efficient resource allocation.

Moreover, it is worth noting that prioritization is not a one-size-fits-all solution. Different tasks have different criticality levels, and thus require different priority levels. Some tasks may be less critical but more time-consuming, while others may require frequent access to system resources. As such, the priority level should be carefully selected to ensure efficient task management and optimize system performance.

In conclusion, understanding the intricacies of priority levels is essential when programming with esp-idf. By choosing the appropriate priority level for each task, we can ensure efficient task management, avoid system performance degradation, and optimize system performance. With only 25 priority levels in ESP-IDF, developers have limited flexibility to assign priority levels based on the specific needs of their projects.
